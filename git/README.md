# :deciduous_tree: Работа с git

Постарался собрать то, что очень может пригодиться. Я до упора буду стоять на том, что следует использовать консоль. Если вам ну вот ооочень хочется использовать GUI-инструменты, то пожалуйста, главное - аналогичный результат. Но через консоль реально всё просто, тут будет расписано.

- [Я хочу начать работать. С чего начать?](#heavy_check_mark-я-хочу-начать-работать-с-чего-начать)
- [Я хочу сделать коммит. Как сделать его правильно?](#heavy_check_mark-я-хочу-сделать-коммит-как-сделать-его-правильно)
- [Что делать, если удалённый репозиторий ушёл вперёд?](#heavy_check_mark-что-делать-если-удалённый-репозиторий-ушёл-вперёд)
- [Я понял, что ошибся в коммите, либо хочу добавить ещё какие-то изменения.](#heavy_check_mark-я-понял-что-ошибся-в-коммите-либо-хочу-поменять-их-порядок-либо-хочу-добавить-ещё-какие-то-изменения)
- [При попытке слить изменения получается конфликт. Как его исправить?](#heavy_check_mark-при-попытке-слить-изменения-получается-конфликт-как-его-исправить)
- [Я всё сделал и залил в отдельную ветку. Что дальше?]()
- [Краткое руководство по Vim](#heavy_check_mark-краткое-руководство-по-vim)

## :heavy_check_mark: Я хочу начать работать. С чего начать?

Сначала - загрузить репозиторий к себе:

```shell
git clone ССЫЛКА
# Например
git clone https://github.com/First951/security-company-server.git
```

Теперь нужно перейти в директорию с проектом:

```shell
cd НАЗВАНИЕ_ДИРЕКТОРИИ
# Например
cd security-company-server
```

Дальше нужно сделать отдельную ветку для разработки конкретной функции. Если вы захотели сделать другую функцию, то под неё нужно сделать отдельную ветку.

Создание и переход в ветку:

```shell
git checkout -b НАЗВАНИЕ_ВЕТКИ
# Например
git checkout -b add-voice-input
```

Переход в ветку

```shell
git checkout НАЗВАНИЕ_ВЕТКИ
# Например
git checkout main
```

При переходе на ветку актуальными становятся данные из этой ветки. Всё, что было сделано вне её сохраняется git'ом, но не находятся в текущей директории.

После создания ветки можно начинать делать коммиты.

## :heavy_check_mark: Я хочу сделать коммит. Как сделать его правильно?

### Добавление файлов в коммит

Есть 2 пути:
- Добавить весь проект/директорию сразу (Можно только при маленьких изменениях. Используется вместо указания каждого файла как в следующем случае)
- Добавить 1 или несколько конкретных файлов вручную

#### `git add .`

Перейдите в папку с проектом, либо любую другую папку, закоммитить которую вы хотите циликом. Введите

```shell
git add .
```

После этого все подходящие файлы будут добавлены в коммит. В папке с проектом лежит скрытый файл .gitignore, содержащий список файлов, который команда add будет игнорировать. Так, например, папки build и gradle будут проигнорированы. При необходимости в этот файл можно записывать и новые строки.

Проверить текущую отслеживаемость файлов можно через команду status:

```shell
git status
```

Отменить добавление файлов в коммит можно с помощью команды reset:

```shell
git resest
```

#### `git add ФАЙЛ`

Файлы можно добавлять просто перечисляя их:

```shell
git add src/java/Main.java
```

Такой способ предпочтительней, когда изменений собралось много и их нужно разбить на коммиты, либо закомитить один файлик, исправляющий предыдущие коммиты. Об этом будет дальше

### Типы коммитов

Каждый коммит принадлежит какой-то из категорий. Далее нам эта классификация понадобится. Сейчас нужно определить, к какой из групп относится ваш коммит:

| Название | Что означает |
| - | - |
| build | Сборка проекта или изменения внешних зависимостей |
| docs | Всё, что касается документации |
| feat | Добавление нового функционала уровня приложения |
| fix | Исправление ошибок |
| perf | Изменения направленные на улучшение производительности |
| refactor | Правки кода без исправления ошибок или добавления новых функций |
| revert | Откат на предыдущие коммиты |
| style | Правки по кодстайлу (табы, отступы, точки, запятые и т.д.) |
| test | Добавление тестов |
| chore | Обычное обслуживание кода |

### Название коммита

:fire: **Важно: Все коммиты мы делаем на РУССКОМ языке. Из-за того, что сейчас намного важнее понимать друг друга, чем соответствовать каким-то стандартам.**

Теперь нужно коротко описать изменения, причём:
- Это описание должно быть в повелительном наклонении (не Добавлено, а Добавить, не Исправлено, а Исправить)
- Вместе с типом коммита оно должно занимать не более 50 символов. Тип коммита вставляется в начало с `:` и пробелом
- Точка в конце не ставится

Правильно названный коммит: `docs: Добавить инструкцию по сборке`

### Само создание коммита

Теперь, наконец, вводим команду для коммита.

:fire: Я настаиваю на том, чтобы **НЕ** использовать `git commit -m "docs: Добавить инструкцию по сборке"`. Если вы делаете коммит так, то непонятно какой длины краткое и полное описание.

Рекомендую использовать эту команду в другой форме:

```shell
git commit # Да, без аргументов вообще
```

Если вы используете git bash, то после этой команды должен открыться Vim. Короткая инструкция как там написать текст и как из него выйти - [ниже](#краткое-руководство-по-vim)

Если вы выйдете ничего не написав, то коммит ничего не будет сделано. Файлы останутся подготовленными к комиту, но сам коммит совершён не будет.

- В первую строчку пишете название коммита, которое определили раньше. Если длина превышает 50 символов, то Vim должен подсвечивать лишний текст другим цветом
- Вторую строчку оставляете пустой, если будете писать описание (Следующий шаг). Иначе ничего не пишете
- В третью и далее пишете описание (Опционально, но очень желательно). Сюда нужно написать что сделано и почему. Можете делать дополнительные пустые строки для разделения, если нужно. :fire: **Важно: каждая строка подробного описания должна быть не больше 72 символов. Vim должен переносить слова сам, но он не всегда понимает что это нужно делать, поэтому сами тоже за этим следите**. И поставьте точку в конце подробного описания

Правильно оформленный коммит:

```
docs: Добавить инструкцию по сборке

Не каждый в команде разработчиков умеет работать с gradle. Для того,
чтобы они тоже могли запускать проекты, была добавлена пошаговая
инструкция для сборки.
```

Теперь, когда вы выйдете из Vim, коммит будет записан.

:fire: **Пожалуйста, не торопитесь отправлять коммиты на удалённый репозиторий. Да, не нужно досиживать до того, когда код будет полностью готов - возможные правки проще внести раньше. Ведь когда код будет уже готов, исправлять его целиком тоже такое себе развлечение. Но если у вас будет ошибка в коде, то её можно безболезненно изменить только тогда, когда вы ещё не залили изменения на удалённый репозиторий**

:fire: **Не нужно сливать изменения с веткой main. Я заблокировал возможность заливать измененя туда всем, включая себя. Всё сливается только через pull request'ы и только после проверки как минимум двумя другими участниками**

## :heavy_check_mark: Что делать, если удалённый репозиторий ушёл вперёд?

Нужно забрать данные к себе. Если вы просто находитесь в ветке, без локальных изменений, то смело пишите

```shell
git pull
```

Это вытянет изменения и переместит на их конец

Если у вас есть локальные изменения, при этом вы делали `checkout` от ветки, которая тоже продвинулась вперёд, то следует вытянуть изменения и переместиться:

```
git fetch
git rebase НАЗВАНИЕ_ВЕТКИ
# Например, если был checkout с ветки main, то
git rebase main
```

## :heavy_check_mark: Я понял, что ошибся в коммите, либо хочу поменять их порядок, либо хочу добавить ещё какие-то изменения.

Возможны 2 ситуации: либо вы успели отправить данные в удалённый репозоторий, либо нет

### Если изменения уже отправлены

Тогда ничего не поделать, нужно создавать новый коммит типа `fix` и уже в нём исправлять изменения. **Пожалуйста, не используйте `push -f`. Это может ломать то, что сделали другие пользователи**.

### Если изменения ещё не отправлены

Тогда вся неотправленная история в вашем полном распоряжении!

Посмотреть историю коммитов можно командой:

```shell
git log --oneline
# Либо с описаниями:
git log
```

Вывод будет примерно вот таким:

```
52e98c6 (HEAD -> add-git, origin/add-git) docs: Создать шаблонный README со ссылкой на него
6b2cea9 (origin/main, main) Merge pull request #2 from First951/add-java
9f5797f (origin/add-java, add-java) docs: Добавить узкие ссылки в главный README.md
2d9a9db docs: Убрать большой текст в README для java
2f95813 (add-java-javadoc) docs: Добавить указания по JavaDoc
0824810 (add-java-test) docs: Добавить указания к написанию тестов
```

Для того, чтобы изменять коммиты с определённого, нужно взять код предыдущего коммита и поместить его в команду `git rebase -i КОД`. Например, мы хотим изменить коммиты начиная с `6b2cea9`. Тогда команда будет такая:

```shell
git rebase -i 9f5797f
```

Того же самого можно добиться, если ввести команду:

```shell
git rebase -i HEAD^^
# Две крышечки означают "На 2 коммита вверх". То же самое можно записать по-другому:
git rebase -i HEAD~2
```

Теперь можно проводить манипуляции с коммитами. Если изменить `pick` на что-нибудь, то структура будет меняться. Короткая инструкция по использованию Vim [ниже](#краткое-руководство-по-vim).

Если удалить строку, то комит будет удалён.

Если переместить строки местами, порядок коммитов будет изменён

Примеры того, на что можно заменит pick:

| Что писать | Что произойдет |
| - | - |
| fixup | Название и описание указанного коммита стираются, содержимое присоединяется к предыдущему коммиту выше |
| squash | Объединить указанный коммит и коммит выше. Отличается от предыдущей команды тем, что в процессе слияния предлагает объединить названия и описания этих двух коммитов |
| edit | Даёт возможность редактировать указанный коммит |

Больше я никакими командами не пользовался, но если найдёте ещё - можете использовать и их.

Если вы использовали команды типа squash или edit, либо если при слиянии произошёл конфликт, то git остановит свою работу до ввода команд. Конфликты рассмотрим [ниже](#при-попытке-слить-изменения-получается-конфликт-как-его-исправить), сейчас займёмся редактированием.

После выхода из Vim git останавливается и ждёт команд. Для редактирования нужно ввести команду:

```shell
git commit --amend
```

Откроется окно для редактирования как обычное окно для создания коммитов

Когда изменения внесены и Vim закрыт, для продолжения работы git нужно ввеси команду:

```shell
git rebase --continue
```

git продолжит свою работу до следующей остановки, либо до конца, изменив коммиты как указано.

Если в процессе изменения коммитов вы передумали их изменять, то введите команду

```shell
git rebase --abort
```

И все внесённые изменения, начиная с `git rebase -i` будут отменены

## :heavy_check_mark: При попытке слить изменения получается конфликт. Как его исправить?

Проблему лучше рассмотреть на конкретном примере. Возьмём такой текстовый файл:

```
КОД
КОД
КОД
Андрей
КОД
КОД
КОД
```

В коммите поменяем строчку:

```
КОД
КОД
КОД
Привет, Андрей
КОД
КОД
КОД
```

В следующем коммите поменяем ещё раз эту же строчку:

```
КОД
КОД
КОД
Андрей, улыбнись
КОД
КОД
КОД
```

Теперь сделаем `git rebase -i afa8e37` и поменяем эти 2 коммита местами. Выйдем. Возник конфликт:

```
Автослияние code
КОНФЛИКТ (содержимое): Конфликт слияния в code
error: не удалось применить коммит e7581dc... Андрей, улыбнись
подсказка: Resolve all conflicts manually, mark them as resolved with
подсказка: "git add/rm <conflicted_files>", then run "git rebase --continue".
подсказка: You can instead skip this commit: run "git rebase --skip".
подсказка: To abort and get back to the state before "git rebase", run "git rebase --abort".
Не удалось применить коммит e7581dc... Андрей, улыбнись
```

Откроем наш файл. Теперь он выглядит вот так:

```
КОД
КОД
КОД
<<<<<<< HEAD
Андрей
=======
Андрей, улыбнись
>>>>>>> e7581dc (Андрей, улыбнись)
КОД
КОД
КОД
```

git добавил изменения из обоих коммитов, но даже не из 3-го и 2-го - он не может слить даже 1-ый со 3-им. Отредактируем этот файл любым удобным способом. Допустим, мы хотим оставить "Андрей, улыбнись". Проводим файл к виду:

```
КОД
КОД
КОД
Андрей, улыбнись
КОД
КОД
КОД
```

Вводим `git add .`, далее `git rebase --continue`. Если хотим, то меняем файл и выходим из Vim.
Теперь возник конфликт между 3-им и 2-ым коммитами:

```
[отделённый HEAD 24ebd5b] Андрей, улыбнись
 1 file changed, 1 insertion(+), 1 deletion(-)
Автослияние code
КОНФЛИКТ (содержимое): Конфликт слияния в code
error: не удалось применить коммит a61e383... Привет, Андрей
подсказка: Resolve all conflicts manually, mark them as resolved with
подсказка: "git add/rm <conflicted_files>", then run "git rebase --continue".
подсказка: You can instead skip this commit: run "git rebase --skip".
подсказка: To abort and get back to the state before "git rebase", run "git rebase --abort".
Не удалось применить коммит a61e383... Привет, Андрей
```

Файл выглядит вот так:

```
КОД
КОД
КОД
<<<<<<< HEAD
Андрей, улыбнись
=======
Привет, Андрей
>>>>>>> a61e383 (Привет, Андрей)
КОД
КОД
КОД
```

:fire: **Важный момент: мы определяем конечный вид файла, а не выбираем один из 2-ух вариантов.** Поэтому можем отредактировать файл, чтобы он выглядел вот так:

```
КОД
КОД
КОД
Привет, Андрей. Улыбнись!
КОД
КОД
КОД
```

После чего снова ввести команды `git add .` и `git rebase --continue`. Теперь наш файл выглядит так, как в последнем примере, а коммиты поменяны местами.

## :heavy_check_mark: Я всё сделал и залил в отдельную ветку. Что дальше?

Ура, изменения сделаны, конфликтов нет, всё залито в неосновную ветку на GitHub и готовы и слитию с main.

Теперь нужно перейти к ветке, нажать на создание Pull Request'а, ввести название и описание (Поддерживается Markdown, ограничений на длину нет).

После отправки запрос должны проверить как минимум ещё 2 человека и тогда его можно будет сливать с main.

## :heavy_check_mark: Краткое руководство по Vim

Это консольный редактор и хотя вы можете добавить туда частичную поддержку мыши, делать это сейчас уж точно не нужно. Нам потребуется всего пара сочетаний клавиш.

У Vim есть несколько режимов работы, мы будем использовать только 2: Normal - режим просмотра и  Insert - режим редактирования

`a` - перейти в режим редактирования

`Esc` - перейти в режим просмотра

При нажимании клавиш в режиме редактирования будут вставляться привычные символы как в обычном текстовом редакторе

При нажимании клавиш в режиме просмотра клавиши обрабатываются как клавиши Vim

- `dd` - удалить строку, записав её в буфер обмена внутри Vim
- `p` - вставить строку из буфера обмена ниже текущей
- `u` - Отменить предыдущее действие

Если в режиме просмотра ввести `:`, то будет включён ввод команд. Выйти из него можно либо выполнив команду, либо стерев `:`

Нужные команды для режима просмотра:

- `:x` - записать файл и выйти из Vim
- `:w` - записать файл
- `:q` - выйти из Vim. При несохранённых изменениях будет требовать сохранения
- `:q!` - принудительно выйти из Vim игнорируя несохранённые изменения

Для работы с git этих команд достаточно
